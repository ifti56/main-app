name: Sync Demo with Main via Copilot

on:
  push:
    branches:
      - main

jobs:
  sync-demo:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      pull-requests: write

    env:
      DEMO_REPO_TOKEN: ${{ secrets.DEMO_REPO_TOKEN }}
      IGNORE_PATHS: "src/pages/**,src/demo-specific/**"

    steps:
      # Step 1: Checkout main-app
      - name: Checkout main-app
        uses: actions/checkout@v4
        with:
          path: main-app

      # Step 2: Checkout demo-app
      - name: Checkout demo-app
        uses: actions/checkout@v4
        with:
          repository: ifti56/demo-app
          token: ${{ secrets.DEMO_REPO_TOKEN }}
          path: demo-app

      # Step 3: Generate surgical diff of changed lines only
      - name: Generate main changes diff
        id: generate-diff
        run: |
          cd main-app
          # Fetch full history including all commits and tags
          git fetch --deepen=999999 origin main || git fetch origin main
          
          # Use HEAD and HEAD~1 (last two commits)
          BEFORE="HEAD~1"
          AFTER="HEAD"
          
          echo "--- DIFF DEBUG ---"
          echo "BEFORE: $BEFORE"
          echo "AFTER:  $AFTER"
          echo "Total commits on main:"
          git rev-list --count origin/main
          echo "Commit info for BEFORE:"
          git show --no-patch --format="%H %ci %s" $BEFORE 2>/dev/null || echo "(BEFORE unavailable)"
          echo "Commit info for AFTER:"
          git show --no-patch --format="%H %ci %s" $AFTER 2>/dev/null || echo "(AFTER unavailable)"

          # Limit the diff to source files only to avoid applying workflow or config files
          git diff "$BEFORE" "$AFTER" --unified=0 -- src > ../main_changes.diff || true
          git diff --name-only "$BEFORE" "$AFTER" -- src > ../main_changed_files.txt || true
          echo "Changed files (limited to src/):"
          cat ../main_changed_files.txt || true
          echo "Diff between $BEFORE and $AFTER (src/):"
          cat ../main_changes.diff || true
          echo "--- END DIFF DEBUG ---"

      # Step 4: Apply changes to demo-app using git apply
      - name: Apply changes to demo-app
        id: apply-changes
        run: |
          cd demo-app
          # Check if diff file has content
          if [ ! -s ../main_changes.diff ]; then
            echo "changes_made=false" >> $GITHUB_OUTPUT
            echo "â„¹ No changes to apply (branches are identical)"
            exit 0
          fi
          
          echo "changes_made=true" >> $GITHUB_OUTPUT
          
          # Get list of new files (added) from main-app
          NEW_FILES=$(cd ../main-app && git diff HEAD~1 HEAD --name-only --diff-filter=A -- src 2>/dev/null || true)
          
          if [ ! -z "$NEW_FILES" ]; then
            echo "ðŸ“„ New files detected:"
            echo "$NEW_FILES"
            # Copy new files from main-app to demo-app
            for FILE in $NEW_FILES; do
              mkdir -p "$(dirname "$FILE")"
              cp "../main-app/$FILE" "$FILE"
              echo "  âœ“ Copied $FILE"
            done
          fi
          
          # Get list of modified files (exclude new files) from main-app
          MODIFIED_FILES=$(cd ../main-app && git diff HEAD~1 HEAD --name-only --diff-filter=M -- src 2>/dev/null || true)
          
          if [ ! -z "$MODIFIED_FILES" ]; then
            echo "âœï¸ Modified files detected:"
            echo "$MODIFIED_FILES"
            
            # Ensure each modified file exists in demo-app; if missing, create it from main-app
            for FILE in $MODIFIED_FILES; do
              if [ ! -f "$FILE" ]; then
                echo "ðŸ“„ $FILE is modified in main-app but missing in demo-app; copying it over"
                mkdir -p "$(dirname "$FILE")"
                cp "../main-app/$FILE" "$FILE"
              fi
            done
            
            # Backup files in demo-app that contain intentional-difference markers so we can restore those blocks
            INTENTIONAL_FILES=""
            for FILE in $MODIFIED_FILES; do
              if [ -f "$FILE" ] && grep -q 'INTENTIONAL-START' "$FILE"; then
                mkdir -p "../demo-app_backups/$(dirname "$FILE")"
                cp "$FILE" "../demo-app_backups/$FILE"
                INTENTIONAL_FILES="$INTENTIONAL_FILES $FILE"
              fi
            done
            
            # Create a filtered diff that only includes modifications (not additions)
            cd ../main-app
            git diff HEAD~1 HEAD --unified=0 --diff-filter=M -- src > ../main_changes_modified_only.diff || true
            cd ../demo-app
            
            # Apply only the modified files diff
            if [ -s ../main_changes_modified_only.diff ]; then
              if git apply ../main_changes_modified_only.diff --check 2>/dev/null; then
                git apply ../main_changes_modified_only.diff
                echo "âœ“ Modified files applied successfully"
              else
                echo "âš  Some hunks could not be applied - trying with --3way"
                git apply --3way ../main_changes_modified_only.diff || {
                  echo "âœ— Failed to apply modified files diff with --3way"
                  exit 1
                }
              fi
              
              # After applying diffs, restore intentional blocks from backups so demo-specific code stays untouched
              if [ ! -z "$INTENTIONAL_FILES" ]; then
                echo "â™» Restoring intentional blocks in demo-app for files:"
                echo "$INTENTIONAL_FILES"
                for FILE in $INTENTIONAL_FILES; do
                  BACKUP="../demo-app_backups/$FILE"
                  if [ -f "$BACKUP" ]; then
                    TARGET_FILE="$FILE" BACKUP_FILE="$BACKUP" python - << 'PY'
                    import os

                    file_path = os.environ["TARGET_FILE"]
                    backup_path = os.environ["BACKUP_FILE"]

                    with open(file_path, "r", encoding="utf-8") as f:
                        new_lines = f.readlines()

                    with open(backup_path, "r", encoding="utf-8") as f:
                        orig_lines = f.readlines()


                    def restore_blocks(new, orig):
                        result = []
                        i_new = 0
                        i_orig = 0
                        n_new = len(new)
                        n_orig = len(orig)

                        while i_new < n_new:
                            line_new = new[i_new]
                            if "INTENTIONAL-START" in line_new:
                                # Find corresponding block in original file
                                start_o = None
                                for j in range(i_orig, n_orig):
                                    if "INTENTIONAL-START" in orig[j]:
                                        start_o = j
                                        break

                                if start_o is None:
                                    # No corresponding block in original; keep new block as-is
                                    result.append(line_new)
                                    i_new += 1
                                    continue

                                # Collect original block (from START to END inclusive)
                                block = []
                                k = start_o
                                while k < n_orig:
                                    block.append(orig[k])
                                    if "INTENTIONAL-END" in orig[k]:
                                        k += 1
                                        break
                                    k += 1

                                # Append original block to result
                                result.extend(block)
                                i_orig = k

                                # Skip corresponding block in new file
                                i_new += 1
                                while i_new < n_new:
                                    if "INTENTIONAL-END" in new[i_new]:
                                        i_new += 1
                                        break
                                    i_new += 1
                            else:
                                result.append(line_new)
                                i_new += 1

                        return result


                    restored = restore_blocks(new_lines, orig_lines)

                    with open(file_path, "w", encoding="utf-8") as f:
                        f.writelines(restored)
          PY
                  fi
                done
              fi
            fi
          fi

      # Step 5: Commit changes to new branch in demo-app
      - name: Commit changes
        if: steps.apply-changes.outputs.changes_made == 'true'
        run: |
          cd demo-app
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b sync/auto-${GITHUB_RUN_ID}
          git add .
          git commit -m "chore(sync): Auto-sync from main-app (${GITHUB_SHA::7})" || echo "No changes to commit"

      # Step 6: Push branch to demo-app
      - name: Push branch
        if: steps.apply-changes.outputs.changes_made == 'true'
        run: |
          cd demo-app
          git push origin HEAD

      # Step 7: Create Pull Request
      - name: Create Pull Request
        if: steps.apply-changes.outputs.changes_made == 'true'
        env:
          GH_TOKEN: ${{ secrets.DEMO_REPO_TOKEN }}
        run: |
          cd demo-app
          gh pr create \
            --title "chore(sync): Automated Demo Sync" \
            --body "This PR was automatically generated to sync demo-app with main-app.
          
          Main commit: ${{ github.sha }}
          - Applied changes from main-app
          - Files in ignore list skipped" \
            --base main \
            --head sync/auto-${GITHUB_RUN_ID}
